import networkx as nx
import heapq

# Create a multilayer graph using NetworkX
def create_multilayer_graph():
    G = nx.DiGraph()  # Directed graph for this example
    
    # Layer 1 - Adding nodes and edges
    G.add_edge('A', 'B', weight=1, layer=1)
    G.add_edge('B', 'C', weight=2, layer=1)
    G.add_edge('C', 'D', weight=1, layer=1)
    
    # Layer 2 - Adding nodes and edges
    G.add_edge('E', 'F', weight=2, layer=2)
    G.add_edge('F', 'G', weight=3, layer=2)
    
    # Inter-layer edges (transition between layers)
    G.add_edge('C', 'E', weight=5, layer=0)  # Layer 1 -> Layer 2
    G.add_edge('G', 'A', weight=4, layer=0)  # Layer 2 -> Layer 1
    
    return G

# Dijkstra's Algorithm adapted for multilayer graph
def dijkstra_multilayer(G, start, goal):
    # Priority queue for Dijkstra's algorithm
    pq = [(0, start)]
    distances = {start: 0}
    previous_nodes = {start: None}
    
    while pq:
        current_distance, current_node = heapq.heappop(pq)
        
        if current_node == goal:
            break
        
        # Get neighbors in the current layer
        for neighbor in G.neighbors(current_node):
            weight = G[current_node][neighbor]['weight']
            new_distance = current_distance + weight
            
            # Check if this path is better than the previous one
            if neighbor not in distances or new_distance < distances[neighbor]:
                distances[neighbor] = new_distance
                previous_nodes[neighbor] = current_node
                heapq.heappush(pq, (new_distance, neighbor))
                
                # Handle inter-layer connections
                if G[current_node][neighbor]['layer'] == 0:
                    inter_layer_transition_weight = G[current_node][neighbor]['weight']
                    inter_layer_node = neighbor
                    new_distance = current_distance + inter_layer_transition_weight
                    
                    if inter_layer_node not in distances or new_distance < distances[inter_layer_node]:
                        distances[inter_layer_node] = new_distance
                        previous_nodes[inter_layer_node] = current_node
                        heapq.heappush(pq, (new_distance, inter_layer_node))
    
    # Reconstruct the path
    path = []
    current_node = goal
    while current_node is not None:
        path.append(current_node)
        current_node = previous_nodes[current_node]
    
    return path[::-1], distances[goal]

# A* Algorithm adapted for multilayer graph
def a_star_multilayer(G, start, goal, heuristic):
    # Priority queue for A* algorithm
    pq = [(0 + heuristic[start], 0, start)]  # (f, g, node)
    g_scores = {start: 0}
    f_scores = {start: heuristic[start]}
    previous_nodes = {start: None}
    
    while pq:
        _, current_g, current_node = heapq.heappop(pq)
        
        if current_node == goal:
            break
        
        # Get neighbors in the current layer
        for neighbor in G.neighbors(current_node):
            weight = G[current_node][neighbor]['weight']
            new_g_score = current_g + weight
            new_f_score = new_g_score + heuristic[neighbor]
            
            # Check if this path is better than the previous one
            if neighbor not in g_scores or new_g_score < g_scores[neighbor]:
                g_scores[neighbor] = new_g_score
                f_scores[neighbor] = new_f_score
                previous_nodes[neighbor] = current_node
                heapq.heappush(pq, (new_f_score, new_g_score, neighbor))
                
                # Handle inter-layer connections
                if G[current_node][neighbor]['layer'] == 0:
                    inter_layer_transition_weight = G[current_node][neighbor]['weight']
                    inter_layer_node = neighbor
                    new_g_score = current_g + inter_layer_transition_weight
                    
                    if inter_layer_node not in g_scores or new_g_score < g_scores[inter_layer_node]:
                        g_scores[inter_layer_node] = new_g_score
                        f_scores[inter_layer_node] = new_g_score + heuristic[inter_layer_node]
                        previous_nodes[inter_layer_node] = current_node
                        heapq.heappush(pq, (new_g_score + heuristic[inter_layer_node], new_g_score, inter_layer_node))
    
    # Reconstruct the path
    path = []
    current_node = goal
    while current_node is not None:
        path.append(current_node)
        current_node = previous_nodes[current_node]
    
    return path[::-1], g_scores[goal]

# Define heuristic function for A*
def heuristic(node):
    heuristics = {
        'A': 6, 'B': 5, 'C': 4, 'D': 3,
        'E': 2, 'F': 1, 'G': 0
    }
    return heuristics.get(node, 0)

# Test the implementation
G = create_multilayer_graph()
start, goal = 'A', 'G'

# Dijkstra's Algorithm Result
dijkstra_path, dijkstra_distance = dijkstra_multilayer(G, start, goal)
print("Dijkstra's Path:", dijkstra_path)
print("Dijkstra's Distance:", dijkstra_distance)

# A* Algorithm Result
a_star_path, a_star_distance = a_star_multilayer(G, start, goal, heuristic)
print("A* Path:", a_star_path)
print("A* Distance:", a_star_distance)
